<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>index</title>
    <!--防止IE进入怪异模式-->
    <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="css/rest.css" type="text/css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <link rel="stylesheet" type="text/css" href="css/layout.css" />
    <link rel="stylesheet" type="text/css" href="css/swiper.min.css" />
    <!-- <script type="text/javascript" src="js/jquery1.42.min.js"></script> -->
    <script type="text/javascript" src="js/swiper.min.js"></script>
    <script type="text/javascript" src="js/base.js"></script>
    <script type="text/javascript" src="js/index.js"></script>
</head>

<body>








    <script>
        /* 
        let 防止数据污染
         */
        for (let i = 0; i < 10; i++) {
            console.log('循环体中' + i);
        }
        //console.log('循环体外'+i);    执行时会发现控制台报错了，找不到循环体外的i变量。 
        let [a, b = "JSPang"] = ['技术胖', undefined];
        let [c, d = "JSPang"] = ['技术胖', null];
        console.log('1' + a + b);
        console.log('2' + c + d);
        //undefined相当于什么都没有，b是默认值。 
        //null相当于有值，但值为null。所以b并没有取默认值，而是解构成了null。 
        /* 
         对象扩展运算符（…）：
         --内存堆栈的引用，而不是真正的赋值。
         */
        /*  let arr1 = ['www123','www456','wwwz789']
        let arr2 = arr1;
         console.log(arr2); 
         arr2.push('new11');
         console.log('数组2：'+arr2);
         console.log('数组1：'+arr1); */    //  --内存堆栈的引用，而不是真正的赋值。

        let arr1 = ['www123', 'www456', 'wwwz789']
        let arr2 = [...arr1];
        console.log(arr2);
        arr2.push('扩展运算符');
        console.log('数组2：' + arr2);
        console.log('数组1：' + arr1);   //可以看到我们的arr1并没有改变，简单的扩展运算符就解决了这个问题。  

        /* 
        rest运算符    它也用…（三个点）来表示
         */
        function jspang(first, ...arg) {
            for (let val of arg) {
                console.log(val);
            }
        }

        jspang(0, 1, 2, 3, 4, 5, 6, 7);         
            //for…of的循环可以避免我们开拓内存空间，增加代码运行效率 .从代码量上我们少打了一些单词，这就是开发效率的提高。

        /* 
        字符串模版:  ``  ${jspang}
        --ES5下必须用+jspang+这样的形式进行拼接，这样很麻烦而且很容易出错。ES6新增了字符串模版
         */
        let JSpang1 = '胖子';
        let ptext = `非常高兴你能看到这篇文章，我是你的老朋友${JSpang1}。这节课我们学习字符串模版。`;
        console.log(ptext)
        //对运算的支持： 
        let n = 1;
        let z = 2;
        let result = `${n + z}`;
        console.log(result)

        /* 
        字符串查找
         */

        let jspang3 = '胖子';
        let text = '非常高兴你能看到这篇文章，我是你的老朋友胖子。这节课我们学习字符串模版。'

        console.log(text.indexOf(jspang3));    //es5 输出了20，我们还要自己判断。 
        console.log(text.includes(jspang3));    //ES6直接用includes就可以判断，不再返回索引值，返回true这样的结果我们更喜欢，更直接  
        //判断开头是否存在： 	blog.startsWith(jspang);
        //判断结尾是否存在：blog.endsWith(jspang);
        //starts和ends 后边都要加s，希望小伙伴们不要采坑。

        //--复制字符串
        //我们有时候是需要字符串重复的，比如分隔符和特殊符号，这时候复制字符串就派上用场了，语法很简单。
        document.write('jssss|,,'.repeat(5));

        /*
        第6节：ES6数字操作
        //--数字验证Number.isFinite( xx )
        // 可以使用Number.isFinite( )来进行数字验证，只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。
        */
        let m = 10 / 8;
        console.log(Number.isFinite(m));  //true
        console.log(Number.isFinite('m'));  //false
        console.log(Number.isFinite(NaN));  //false
        console.log(Number.isFinite(undefined));  //false
        console.log(Number.isFinite(null));  //false

        //NaN验证   NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 
        console.log(Number.isNaN(NaN));
        //判断是否为整数Number.isInteger(xx)

        let a2 = 123.1;
        console.log(Number.isInteger(a2)); //false
        //整数转换Number.parseInt(xxx)和浮点型转换Number.parseFloat(xxx) 
        let ac1 = 9.85;
        console.log(Number.parseInt(ac1)); //9
        console.log(Number.parseFloat(ac1)); //9.85
        //整数取值范围操作 
        //--整数的操作是有一个取值范围的，它的取值范围就是2的53次方。我们先用程序来看一下这个数字是什么.
        let ac2 = Math.pow(2, 53) - 1;
        console.log(ac2); //9007199254740991   在我们计算时会经常超出这个值，所以我们要进行判断，ES6提供了一个常数，叫做最大安全整数，以后就不需要我们计算了。
        //最大安全整数
        console.log(Number.MAX_SAFE_INTEGER);
        //最小安全整数
        console.log(Number.MIN_SAFE_INTEGER);
        /***
         **   第7节：ES6中新增的数组知识（1）
         ** 
          */
        let json = {
            '0': 'jspang',
            '1': '技术胖',
            '2': '大胖逼逼叨',
            length: 3
        }

        let arr = Array.from(json);   //JSON代码转换成数组
        console.log(arr)

        // --Array.of()方法：  把一堆数字转换成数组  
        //这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。
        //Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。
        //Array.of()方法基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。
        //Array.of()方法总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 
        //Array.of()方法可以用下面的代码模拟实现。
        function ArrayOf() {
            return [].slice.call(arguments);
        }

        let ac4 = Array.of('可以用', '值组', '代码模', '返回一')
        console.log(ac4)

        // --find( )实例方法:
        //所谓的实例方法就是并不是以Array对象开始的，而是必须有一个已经存在的数组
        //在find方法中我们需要传入一个匿名函数，函数需要传入三个参数：
        // 1 value：表示当前查找的值。
        // 2 index：表示当前查找的数组索引。
        //3  arr：表示当前数组。  

        let ac5 = [1, 2, 3, 4, 5, 100, 9, 10, 52, 0]
        console.log(
            ac5.find(function (value, index, arr) {
                /*  return false */
                return value > 5;    //返回100  //在函数中如果找到符合条件的数组元素就进行return，并停止查找
            })
        )

        /* *
        *
        *第8节：ES6中新增的数组知识（2）
        **/

        //fill( )实例方法： 
        // fill()也是一个实例方法，它的作用是把数组进行填充，它接收三个参数:
        //第一个参数是填充的变量
        // 第二个是开始填充的位置
        // 第三个是填充到的位置。也可以说多少个 
        let ac6 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        ac6.fill('jspang', 0, 3);
        console.log(ac6);
        //--数组的遍历 for…of循环：
        //这种形式比ES5的for循环要简单而且高效。先来看一个最简单的for…of循环。
        let ac7 = ['第一个', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];
        for (let item of ac7) {     //最简单的for…of循环,遍历数组
            console.log(item);
        }
        for (let index of ac7.keys()) {     //有时候开发中是需要数组的索引的，输出数组索引。
            console.log(index);
        }
        //--同时输出数组的内容和索引：我们用entries()这个实例方法，配合我们的for…of循环就可以同时输出内容和索引了。
        for (let [index, val] of ac7.entries()) {
            console.log(index + ':' + val);
        }

        // -- entries( )实例方法 
        //可迭代对象， 该对象包含了数组的键值对：
        //entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。
        //迭代对象中数组的索引值作为 key， 数组元素作为 value。
        //entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。我们来看下面的代码：
        // (2)[0, "第一个"]
        // (2)[1, "two"]
        // (2)[2, "three"]
        let list = ac7.entries();
        console.log(list.next().value);
        console.log(list.next().value);
        console.log(list.next().value);

        /* 
        *第9节：ES6中的箭头函数和扩展
        *
        **/
        function plus(a, b = 7) {
            return a + b;
        }
        console.log(plus(1))
        //主动抛出错误
        function mistake(a, b = 7) {
            if (a == 0) {
                throw new Error("this is Error")  // throw new Error  把新的错误抛出来
            }
            return a + b;
        }
        //console.log(mistake(0))

        //   函数中的严谨模式

        /*     function add(a, b = 1) {         //你会发现浏览器控制台报错，这是ES6中的一个坑
                'use strict'                 //这个错误的原因就是如果你使用了默认值，再使用严谨模式的话，就会有冲突，所以我们要取消默认值的操作
                if (a == 0) {
                    throw new Error('This is error');
                }
                return a + b;
            }
            console.log(add(1)); */

        function add(a, b) {
            'use strict'
            if (a == 0) {
                throw new Error('遇到错误了');
            }
            return a + b;
        }
        console.log(add(1, 9));           //取消默认值的操作，这时候你在运行就正常了 

        //--获得需要传递的参数个数
        //如果你在使用别人的框架时，不知道别人的函数需要传递几个参数怎么办？ES6为我们提供了得到参数的方法(xxx.length).我们用上边的代码看一下需要传递的参数个数。
        function add2(a, b) {
            //    'use strict'
            if (a == 0) {
                throw new Error('This is error');
            }
            return a + b;
        }
        console.log(add2.length);

        // -- 箭头函数 
        var add3 = (a, b = 7) => a + b;
        console.log(add3(1));
        //-- {}的使用
        //在箭头函数中，方法体内如果是两句话，那就需要在方法体外边加上{}括号。例如下边的代码就必须使用{}.
        var add4 = (a, b = 7) => {
            console.log('11111');
            return a + b;
        }
        console.log(add4(1));
        //箭头函数中不可加new，也就是说箭头函数不能当构造函数进行使用
        /*
        *第10节：ES6中的函数和数组补漏
        *
        * */
        // --对象的函数解构
        //直接把这个JSON格式数据当作参数，传递到函数内部进行处理。ES6就为我们提供了这样的解构赋值。
        //***

        //--数组的函数解构
        //函数能解构JSON，那解构我们的数组就更不在话下了，我们看下边的代码。我们声明一个数组，然后写一个方法，最后用…进行解构赋值。
        let add5 = ['jspang', '技术胖', '免费教程'];
        function fun(a, b, c) {
            console.log(a, b, c);
        }
        fun(...add5);
        // --in的用法 
        //in是用来判断对象或者数组中是否存在某个值的。我们先来看一下用in如何判断对象里是否有某个值。
        let obj = {
            a: 'jspan',
            b: 'pang'
        }
        console.log('a' in obj); //true
        console.log('b' in obj);//true
        console.log('c' in obj);//false 

        // --数组判断
        //看一下ES5判断的弊端，以前会使用length属性进行判断，为0表示没有数组元素。但是这并不准确，或者说真实开发中有弊端。 
        let add6 = [, , , , ,];
        console.log(add6.length);//5 
        //上边的代码输出了5，但是数组中其实全是空值，这就是一个坑啊。那用ES6的in就可以解决这个问题。 
        let add7 = [, , , , ,];
        console.log(0 in add7); //false 
        let add8 = ['jspang', '技术胖', '免费教程'];
        console.log(0 in add8); //true 
        /* 注意：这里的0指的是数组下标位置是否为空。 */
        // --数组的遍历方法 
        //1.forEach
        let add9 = ['jspang', '技术胖', '前端教程'];
        arr.forEach((val, index) => console.log(index, val));
        /* forEach循环的特点是会自动省略为空的数组元素，相当于直接给我们筛空了。当是有时候也会给我们帮倒忙。 */

        //-- 数组转换字符串
        //在开发中我们经常会碰到把数组输出成字符串的形式，我们今天学两种方法，你要注意两种方法的区别。
        //join()方法 
        let add10 = ['jspang', '技术胖', '前端教程'];
        console.log(add10.join('0-v-0'));
        //join()方法就是在数组元素中间，加了一些间隔，开发中很有用处。
        //toString()方法 
        console.log(add10.toString());
        /* 转换时只是是用逗号隔开了。 */


        /*
        * 第11节：ES6中对象
        *
        * */
        //--对象赋值 
        //ES6允许把声明的变量直接赋值给对象，我们看下面的例子。
        let name = "jspang";
        let skill = 'web';
        var obj2 = { name, skill };

        console.log(obj2);  //Object
        // { name: "jspang", skill: "web" }

        //-- 对象Key值构建 
        //有时候我们会在后台取出key值，而不是我们前台定义好的，这时候我们如何构建我们的key值那。比如我们在后台取了一个key值，然后可以用[ ] 的形式，进行对象的构建。
        let key = 'skill';
        var obj3 = {
            [key]: 'val'
        }
        console.log(obj3.skill);

        // --自定义对象方法 
        //对象方法就是把兑现中的属性，用匿名函数的形式编程方法。这个在以前就有应用，我们这里只是简单的复习一下。
        var obj4 = {
            add: function (a, b) {
                return a + b;
            }
        }
        console.log(obj4.add(1, 2));  //3
        //--Object.is(  ) 对象比较
        //对象的比较方法,以前进行对象值的比较，经常使用===来判断，比如下面的代码：
        var obj5 = { name: 'jspang' };
        var obj6 = { name: 'jspang' };
        console.log(obj5.name === obj6.name);//true
        //那ES6为我们提供了is方法进行对比。
        console.log(Object.is(obj5.name, obj6.name));//true
        //区分=== 和 is方法的区别是什么，看下面的代码输出结果。
        console.log(+0 === -0);  //true
        console.log(NaN === NaN); //false
        console.log(Object.is(+0, -0)); //false
        console.log(Object.is(NaN, NaN)); //true
        //这太诡异了，我要怎么记忆，那技术胖在这里告诉你一个小妙招，===为同值相等，is()为严格相等。

        //Object.assign(  )合并对象
        //对象也有合并方法，那就是assgin(  )
        var ij1 = { a: 'dpang1' }
        var ij2 = { b: 'dpang2' }
        var ij3 = { c: 'dpang3' }
        let idj = Object.assign(ij1, ij2, ij3);
        console.log(idj);  //{a: "dpang1", b: "dpang2", c: "dpang3"}

        /*
        *
        *第12节：Symbol在对象中的作用
        *
        **/
        //我们通过场景应用的方式学习Symbol，它的意思是全局标记。是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用，表示独一无二的值
        //它是JavaScript语言的第七种数据类型，前6种分别是：Undefined、Null、Boolean、String、Number、Object。
        //声明Symbol
        //我们先来回顾一下我们的数据类型，在最后在看看Symbol如何声明，并进行一个数据类型的判断。
        var al = new String;
        var bl = new Number;
        var cl = new Boolean;
        var dl = new Array;
        var el = new Object;
        var f = Symbol();
        console.log(typeof (al));

        var g = Symbol('jspang');
        console.log(g);
        console.log(g.toString());   //toString() 方法可把一个逻辑值转换为字符串，并返回结果。
        //这时候我们仔细看控制台是有区别的，没有toString的是红字，toString的是黑字。
        // --Symbol在对象中的应用 
        var jspang = Symbol();
        var obj8 = {
            [jspang]: 'js胖00'

        }
        console.log(obj8[jspang]);
        obj8[jspang] = 'web';
        console.log(obj8[jspang]);
        console.log(obj8);

        // --Symbol对象元素的保护作用
        //在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用Symbol进行保护。
        var obj15 = { name: 'jspangx..', skill: 'web..', age: 18 };

        for (let item in obj15) {            //没有进行保护的写法：
            console.log(obj15[item])
        }
        //现在我不想别人知道我的年龄，这时候我就可以使用Symbol来进行循环保护。
        let obj16 = { name: 'jspangx~', skill: 'web~' };
        let age = Symbol();
        obj16[age] = 18;
        for (let item in obj16) {
            console.log(obj16[item]);
        }
        console.log(obj16);

        /* 
        *
        *第13节：Set和WeakSet数据结构
        * */
        //这节学习Set数据结构，注意这里不是数据类型，而是数据结构。它是ES6中新的东西，并且很有用处。Set的数据结构是以数组的形式构建的。
        //Set的声明
        let setArr = new Set(['jspang', '技术胖', 'web', 'web', 'jspang']);
        console.log(setArr);//Set  //{ "jspang", "技术胖", "web" } 
        //Set和Array 的区别是Set不允许内部有重复的值，如果有只显示一个，相当于去重。虽然Set很像数组，但是他不是数组。
        //Set值的增删查
        //追加add： 
        //在使用Array的时候，可以用push进行追加值，那Set稍有不同，它用更语义化的add进行追加。
        let setArr2 = new Set(['jspang', '技术胖', 'web', 'jspang']);
        console.log(setArr2);//Set {"jspang", "技术胖", "web"}

        setArr2.add('前端职场');
        console.log(setArr2);
        //删除delete：
        let setArr3 = new Set(['jspang', '技术胖', 'web', 'jspang']);
        console.log(setArr3);//Set { "jspang", "技术胖", "web" }
        setArr3.add('前端职场');
        console.log(setArr3);   //Set {"jspang", "技术胖", "web",  "前端职场"}
        setArr3.delete('前端职场');
        console.log(setArr3); //Set {"jspang", "技术胖", "web"}

        //--查找has：
        //用has进行值的查找，返回的是true或者false。
        let setArr4 = new Set(['jspang', '技术胖', 'web', 'jspang']);
        console.log(setArr4);//Set {"jspang", "技术胖", "web"}
        console.log(setArr4.has('jspang'));//true
        //--删除clear:
        let setArr5 = new Set(['jspang', '技术胖', 'web', 'jspang']);
        console.log(setArr5);//Set  { "jspang", "技术胖", "web" }
        setArr5.clear();
        console.log(setArr5);//null  

        //set的循环  for…of…循环：
        let setArr6 = new Set(['jspang', '技术胖', 'web', 'jspang']);
        for (let item of setArr6) {
            console.log(item);
        }

        /* 
        *
        * 第15节：用Proxy进行预处理
        * */
        //如果你学过我的Vue的课程，一定会知道钩子函数
        //什么是钩子函数: 操作一个对象或者方法时会有几种动作   比如：在运行函数前初始化一些数据，在改变对象值后做一些善后处理 
        //Proxy的存在就可以让我们给函数加上这样的钩子函数 也可以理解为在执行方法前预处理一些代码 可以简单的理解为他是函数或者对象的生命周期。 
        //Proxy的应用可以使函数更加强大，业务逻辑更加清楚，而且在编写自己的框架或者通用组件时非常好用  

        var obj20 = {
            add: function (val) {
                return val + 10;
            },
            name: 'Iam Jspang'
        };

        console.log(obj20.add(100));
        console.log(obj20.name);

        //声明Proxy
        //我们用new的方法对Proxy进行声明。可以看一下声明Proxy的基本形式。
        new Proxy({}, {});   //需要注意的是这里是两个花括号，第一个花括号就相当于我们方法的主体，后边的花括号就是Proxy代理处理区域，相当于我们写钩子函数的地方。
        //现在把上边的obj对象改成我们的Proxy形式。   

        var pro = new Proxy({
            add: function (val) {
                return val + 10;
            },
            name: 'I am JspangNOW'
        },
            {
                get: function (target, key, property) {
                    console.log('come in GetXX7-16');
                    return target[key];
                }
            });
        console.log(pro.name);
        // console.log(pro.add(200));

        //可以在控制台看到结果，先输出了come in Get。相当于在方法调用前的钩子函数。

        /*
       * get属性
        get属性是在你得到某对象属性值时预处理的方法，他接受三个参数

        target：得到的目标值
        key：目标的key值，相当于对象的属性
        property：这个不太常用，用法还在研究中，还请大神指教。
        set属性

        set属性是值你要改变Proxy属性值时，进行的预先处理。它接收四个参数。

        target:目标值。
        key：目标的Key值。
        value：要改变的值。
        receiver：改变前的原始值。

         */

        /*
        * 第16节：promise对象的使用
        * */
        //ES6中的promise的出现给我们很好的解决了回调地狱的问题  

        /* 先留着 */

        /*
        *
        *第17节：class类的使用
        *
        **/
        //我们在ES5中经常使用方法或者对象去模拟类的使用，虽然可以实现功能，但是代码并不优雅，ES6为我们提供了类的使用。需要注意的是我们在写类的时候和ES5中的对象和构造函数要区分开来，不要学混了。
        //类的声明
        //先声明一个最简单的coder类，类里只有一个name方法，方法中打印出传递的参数。
        class coder {
            name(val) {
                console.log(val);
            }
        }
        //--类的使用
        //我们已经声明了一个类，并在类里声明了name方法，现在要实例化类，并使用类中的方法。
        let jspang5 = new coder;
        jspang5.name("guo")
        //--类的多方法声明
        class Coder {
            name(val) {
                console.log(val);
                return val;
            }
            skill(val) {
                console.log(this.name('jspang') + ':' + 'Skill:' + val);
            }
        }
        let jspang6 = new Coder;
        jspang6.name('jspang');
        jspang6.skill('web');
        //这里需要注意的是两个方法中间不要写逗号了，还有这里的this指类本身，还有要注意return 的用法。




        /*
         第18节：模块化操作

        学习地址：ES6基础 https://blog.csdn.net/pyycsd/article/details/78931897
         */
        //ES6为我们增加了模块话操作。模块化操作主要包括两个方面。 
        //export : 负责进行模块化，也是模块的输出。
        //import : 负责把模块引，也是模块的引入操作。
        //export的用法： 
        //export可以让我们把变量，函数，对象进行模块话，提供外部调用接口，让外部进行引用。先来看个最简单的例子，把一个变量模块化。我们新建一个temp.js文件，然后在文件中输出一个模块变量。

        //  export var ab = 'jspang';
        // import { ab } from './temp.js';
        // console.log(ab);  
        //这就是一个最简单的模块的输出和引入。

        // --多变量的输出
        //这里声明了3个变量，需要把这3个变量都进行模块化输出，这时候我们给他们包装成对象就可以了。
     /*    var da = 'qweqweqasd';
        var db = '技术';
        var dc = 'web';
        export { da, db, dc }
        //--函数的模块化输出
        export function add(a, b) {
            return a + b;
        } */

        // as的用法
        //有些时候我们并不想暴露模块里边的变量名称，而给模块起一个更语义话的名称，这时候我们就可以使用as来操作。 
   /*      export {
                x as da,
                y as db,
                z as dc
                
        } */

        


    </script>

</body>

</html>