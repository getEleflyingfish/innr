<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>index</title>
  <!--防止IE进入怪异模式-->
  <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link href="css/rest.css" type="text/css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="css/style.css" />
  <link rel="stylesheet" type="text/css" href="css/layout.css" />
  <link rel="stylesheet" type="text/css" href="css/swiper.min.css" />
  <!-- <script type="text/javascript" src="js/jquery1.42.min.js"></script> -->
  <script type="text/javascript" src="js/swiper.min.js"></script>
  <script type="text/javascript" src="js/base.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>
</head>
<style>
  .hr {
    background: pink;
    height: 2px;
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    box-shadow: 0 0 17px 3px #cccccc;
    margin: 20px 0;
  }

  body {
    text-align: left;
    margin-left: 35%;
  }
</style>

<body>



  <div id="app1"> {{ message }}</div>
  <script>
    var app1 = new Vue({
      el: "#app1",
      data: {
        message: "hello vue one-example"         //用简洁的模板语法来声明式地将数据渲染进 DOM
      }
    });
  </script>
  <div class="hr"></div>

  <!-- /////////////////////////////////// -->

  <div id="app2">
    <span v-bind:title='message'> 鼠标悬停几秒钟查看此处动态绑定的提示信息！two-example </span>
  </div>

  <script>
    var app2 = new Vue({
      el: "#app2",
      data: {
        message: '页面显示时间' + new Date().toLocaleString()    //Date！ 不是data. 系统对象首字母要大写 
        //该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”。
      }
    })   
  </script>
  <div class="hr"></div>
  <!-- /////////////////////////////////// -->


  <div id="app3">
    <p v-if="seen"> 现在你看到我了 three-example</p>
  </div>
  <script>
    var app3 = new Vue({
      el: "#app3",
      data: {
        seen: true         //继续在控制台输入 app3.seen = false，你会发现之前显示的消息消失了。
      }
    })
  </script>
  <div class="hr"></div>


  <!-- /////////////////////////////////// -->

  <div id="app4">

    <!-- 
                    v-for 指令可以绑定数组的数据来渲染一个项目列表：  
                      //todos ---数组
            -->
    <ol>
      <li v-for="todo in todos">
        {{ todo.text }}
      </li>
    </ol>
  </div>
  <script>
    var app4 = new Vue({
      el: "#app4",
      data: {
        todos: [
          {
            text: "学习1 four-example"
          },
          {
            text: "学习2"
          },
          {
            text: "学习3"
          }
        ]                             //在控制台里，输入 app4.todos.push({ text: '新项目' })，你会发现列表最后添加了一个新项目。
      }
    })
  </script>
  <div class="hr"></div>


  <!-- /////////////////////////////////// -->


  <div id="app5">
    <!-- 
                 让用户和你的应用进行交互,用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：
            -->
    <p> {{ message }} </p>
    <button v-on:click="reverseMessage"> 反转消息 </button>
  </div>
  <script>
    var app5 = new Vue({
      el: "#app5",
      data: {
        message: 'hello vue.js'
      },
      methods: {
        reverseMessage: function () {   //split() 方法用于把一个字符串分割成字符串数组。//reverse() 方法用于颠倒数组中元素的顺序。//join() 方法用于把数组中的所有元素放入一个字符串。
          this.message = this.message.split('').reverse().join('');
        }
      }

    })
  </script>
  <div class="hr"></div>

  <!-- /////////////////////////////////// -->
  <div id="app6">
    <!-- 
               v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。
          -->
    <p> {{pp}} </p>
    <input type="text" v-model="pp">
  </div>
  <script>
    var app6 = new Vue({
      el: "#app6",
      data: {
        pp: 'hello vue'
      }
    })
  </script>
  <div class="hr"></div>

  <!-- /////////////////////////////////// -->
  <div id="app7">
    <!-- 
            组件化应用构建
        -->
    <ol>
      <!-- 创建一个 todo-item 组件的实例 -->
      <!--
                        现在我们为每个 todo-item 提供 todo 对象
                        todo 对象是变量，即其内容可以是动态的。
                        我们也需要为每个组件提供一个“key”，稍后再
                        作详细解释。
                  -->
      <todo-item v-for='item in groceryList' v-bind:todo='item' v-bind:key='item.id'></todo-item>
    </ol>
  </div>
  <script>
    //// 定义名为 todo-item 的新组件  
    Vue.component('todo-item', {
      // todo-item 组件现在接受一个
      // "prop"，类似于一个自定义特性。
      // 这个 prop 名为 todo。
      props: ['todo'],
      template: '<li> {{todo.text}} </li>'
    })
    var app7 = new Vue({
      el: "#app7",
      data: {
        groceryList: [
          {
            id: 0, text: '123'
          },
          {
            id: 1, text: '103'
          },
          {
            id: 2, text: '153'
          }
        ]
      }
    })
  </script>
  <div class="hr"></div>

  <!-- /////////////////////////////////// -->
  <div id="">
    <!--  
                  不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：
        -->
    <app-nav></app-nav>
    <app-view>
      <app-sidebar></app-sidebar>
      <app-content></app-content>
    </app-view>
  </div>
  <script>
    var app8 = new Vue({
      el: "",
      data: {

      }
    })
  </script>
  <div class="hr"></div>


  <!-- /////////////////////////////////// -->
  <P>
    Vue 实例<br>
    所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。
    <!--  -->
    <div class="hr"></div>
    数据与方法<br>
  </P>
  <script>
    //我们的数据对象 
    var data = {
      a: 1
    }
    // 该对象被加入到一个 Vue 实例中
    var vm = new Vue({
      data: data
    })
    // 获得这个实例上的属性
    // 返回源数据中对应的字段 
    vm.a === data.a;
    console.log(vm.a === data.a) // => true   
    // 设置属性也会影响到原始数据
    vm.a = 2;
    console.log(data.a) // => 2 
    // ……反之亦然
    data.a = 3
    vm.a // => 3

    document.write('当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性，比如：')

  </script>

  <!-- /////////////////////////////////// -->

  <div id="app8">
    <!-- 
            例外是使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。
        -->
    <p> {{foo}} </p>
    <!-- 这里的 `foo` 不会更新！ -->
    <button v-on:click="foo = 'baz'"> Change it </button>
  </div>
  <script>
    var obj = {
      foo: 'bar'
    }
    Object.freeze(obj);
    var app8 = new Vue({
      el: "#app8",
      data: obj
    })
  </script>
  <div class="hr"></div>

  <p> 除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。例如：</p>
  <div id="example"></div>
  <script>
    var data = { a: 1 }
    var vm = new Vue({
      el: '#example',
      data: data
    })
    vm.$data === data
    console.log(vm.$data === data)  // => true
    vm.$el === document.getElementById('example');
    console.log(vm.$el === document.getElementById('example')) // => true  
    // $watch 是一个实例方法
    vm.$watch('a', function (newValue, oldValue) {
      // 这个回调将在 `vm.a` 改变后调用
      alert(111)
    })
  </script>
  <div class="hr"></div>

  <script>
    document.write('实例生命周期钩子');
    document.write('每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。');
    document.write('比如 <b>created</b> 钩子可以用来在一个实例被创建之后执行代码：');
    new Vue({
      data: {
        a: 110
      },
      created: function () {
        // `this` 指向 vm 实例  
        console.log('a is:' + this.a)
      }
    })
  </script>

  <p>
    <strong> 参数</strong></br>
    一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性：</br>
    如：
  </p>
  <span id="app9" :innerHTML="meet" v-html="data">...</span>
  <script>
    new Vue({
      el: "#app9",
      data: {
        meet: '000'
      }
    })
  </script>

  <p>
    <strong>动态参数</strong></br>
    <strong>v-bind 缩写 : 指令用于设置HTML属性：v-bind:href </strong></br>
    <strong>v-on 缩写 @ 指令用于绑定HTML事件 ：v-on:click </strong></br>
    <span> 2.6.0 新增</span>
    从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：
  </p>
  <a id="app10" :[attributename]='url'>...</a>

  <script>
    new Vue({
      el: "#app10",
      data: {
        attributename: 'href', url: 'www.1111.com'
      },

    })

    var obj1 = {
      a: 1,
      b: 2
    }
    var key = 'a';
    console.log(obj1[key])
  </script>
  <p> 计算属性和侦听器</p>
  <P> 计算属性</P>
  <P>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护</P>
  <P>基础例子</P>
  <div id="app11">
    <ul>
      <li></li>
    </ul>
  </div> 

  <script>

  </script>






































</body>

</html>